import { useState, useMemo, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { 
  ArrowLeft, 
  Plus, 
  Trash2, 
  Bell, 
  BellRing, 
  BellOff,
  Eye, 
  EyeOff,
  TrendingUp,
  TrendingDown,
  RefreshCw,
  Flame,
  Calculator,
  Volume2,
  VolumeX,
  Clock,
  Check,
  Square
} from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";

// Available platforms with their fee structures
const PLATFORMS = [
  { id: "kalshi", name: "Kalshi", feeType: "Sliding", description: "Best for economic data" },
  { id: "polymarket", name: "Polymarket", feeType: "Low-Fixed", description: "Best for sports/crypto" },
  { id: "predictit", name: "PredictIt", feeType: "Profit-Cut", description: "Higher fees, less sharp users" },
  { id: "ibkr", name: "IBKR Forecast", feeType: "Institutional", description: "Most reliable pricing" },
];

// Preset markets - popular questions across platforms (prices fetched live)
const PRESET_MARKETS = [
  { id: "fed-rate-cut", name: "Fed Rate Cut This Year", siteA: "Kalshi", siteB: "Polymarket" },
  { id: "recession-2026", name: "US Recession in 2026", siteA: "Kalshi", siteB: "Polymarket" },
  { id: "trump-approval", name: "Trump Approval Rating Above 50%", siteA: "Kalshi", siteB: "PredictIt" },
  { id: "btc-100k", name: "Bitcoin Above $100K by Year End", siteA: "Kalshi", siteB: "Polymarket" },
];
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import type { Watchlist, Alert } from "@shared/schema";
import { 
  requestNotificationPermission, 
  isNotificationEnabled, 
  triggerUrgentAlert,
  playAlertSound
} from "@/lib/notifications";
import { MarketBrowser } from "@/components/market-browser";

// Calculate fee for a specific platform
// price is in decimal (0-1), contracts is number of contracts
function calculatePlatformFee(platform: string, price: number, contracts: number, mode: "Maker" | "Taker" = "Taker"): number {
  const platformLower = platform.toLowerCase();
  
  if (platformLower === "kalshi") {
    // Kalshi: Sliding scale 0.07 * price * (1-price) per contract
    // Only applies to Taker orders
    if (mode === "Maker") return 0;
    return 0.07 * price * (1 - price) * contracts;
  } else if (platformLower === "polymarket") {
    // Polymarket: 0.01% taker fee on trade value
    // For event markets, effectively 0; for crypto markets, 0.01%
    return (price * contracts) * 0.0001;
  } else if (platformLower === "predictit") {
    // PredictIt: 10% of PROFIT (winnings minus cost)
    // Profit per contract = (1 - price), fee = 10% of that
    return (1.0 - price) * contracts * 0.10;
  } else if (platformLower === "ibkr" || platformLower === "ibkr forecast") {
    // IBKR: $0.01 per contract flat fee
    return contracts * 0.01;
  }
  return 0;
}

// Calculate ROI for a single scenario with any two platforms
// Uses integer share counts for accurate fee calculations
function calculateScenarioRoi(
  platformA: string, priceA: number, 
  platformB: string, priceB: number, 
  investment: number, 
  mode: "Maker" | "Taker" = "Taker"
): number {
  // Total cost per pair = priceA + priceB (before fees)
  const baseCost = priceA + priceB;
  if (baseCost >= 1.0) return 0.0;
  if (investment <= 0) return 0;
  
  // Calculate maximum integer contract pairs we can afford
  // We need to account for fees in determining how many we can buy
  let maxContracts = Math.floor(investment / baseCost);
  
  // Iteratively find the max contracts we can afford with fees
  while (maxContracts > 0) {
    const feeA = calculatePlatformFee(platformA, priceA, maxContracts, mode);
    const feeB = calculatePlatformFee(platformB, priceB, maxContracts, mode);
    const totalCost = (baseCost * maxContracts) + feeA + feeB;
    if (totalCost <= investment) break;
    maxContracts--;
  }
  
  if (maxContracts <= 0) return 0;
  
  // Calculate actual costs and payout
  const feeA = calculatePlatformFee(platformA, priceA, maxContracts, mode);
  const feeB = calculatePlatformFee(platformB, priceB, maxContracts, mode);
  const totalInvested = (baseCost * maxContracts) + feeA + feeB;
  const payout = maxContracts; // Each pair pays out $1
  const netProfit = payout - totalInvested;
  
  return (netProfit / totalInvested) * 100;
}

// Calculate best ROI across both scenarios for any two platforms
// priceAYes and priceBYes are both YES prices for each platform
function calculateBestRoi(
  platformA: string, priceAYes: number,
  platformB: string, priceBYes: number,
  investment: number,
  mode: "Maker" | "Taker" = "Taker"
): { roi: number; scenario: number; feeA: number; feeB: number } {
  // Scenario 1: Buy YES on A + Buy NO on B
  const roi1 = calculateScenarioRoi(platformA, priceAYes, platformB, 1 - priceBYes, investment, mode);
  
  // Scenario 2: Buy NO on A + Buy YES on B
  const roi2 = calculateScenarioRoi(platformA, 1 - priceAYes, platformB, priceBYes, investment, mode);
  
  // Calculate fees for display (for the best scenario)
  const bestScenario = roi1 >= roi2 ? 1 : 2;
  const bestPriceA = bestScenario === 1 ? priceAYes : 1 - priceAYes;
  const bestPriceB = bestScenario === 1 ? 1 - priceBYes : priceBYes;
  const baseCost = bestPriceA + bestPriceB;
  
  // Use integer contracts for fee calculation
  let contracts = baseCost < 1 ? Math.floor(investment / baseCost) : 0;
  while (contracts > 0) {
    const fA = calculatePlatformFee(platformA, bestPriceA, contracts, mode);
    const fB = calculatePlatformFee(platformB, bestPriceB, contracts, mode);
    if ((baseCost * contracts) + fA + fB <= investment) break;
    contracts--;
  }
  
  return {
    roi: Math.max(roi1, roi2),
    scenario: bestScenario,
    feeA: calculatePlatformFee(platformA, bestPriceA, contracts, mode),
    feeB: calculatePlatformFee(platformB, bestPriceB, contracts, mode)
  };
}

export default function SentinelPage() {
  const [marketName, setMarketName] = useState("");
  const [siteAName, setSiteAName] = useState("Kalshi");
  const [siteBName, setSiteBName] = useState("Polymarket");
  const [siteAYes, setSiteAYes] = useState("");
  const [siteBYes, setSiteBYes] = useState("");
  const [investment, setInvestment] = useState("500");
  const [alertThreshold, setAlertThreshold] = useState("3");
  
  // Notification settings
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [soundVolume, setSoundVolume] = useState(70); // 0-100
  
  // Unified scan settings
  const [autoScanEnabled, setAutoScanEnabled] = useState(false);
  const [scanInterval, setScanInterval] = useState("5"); // minutes
  const [lastScan, setLastScan] = useState<Date | null>(null);
  
  // Platform toggles for filtering which platforms to scan
  const [enabledPlatforms, setEnabledPlatforms] = useState<string[]>(["Kalshi", "Polymarket", "PredictIt"]);
  
  // Selected preset markets
  const [selectedPresets, setSelectedPresets] = useState<string[]>([]);
  
  // Toggle platform
  const togglePlatform = (platform: string) => {
    setEnabledPlatforms(prev => {
      if (prev.includes(platform)) {
        // Don't allow disabling all platforms
        if (prev.length <= 1) return prev;
        return prev.filter(p => p !== platform);
      }
      return [...prev, platform];
    });
  };

  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Check notification permission on mount
  useEffect(() => {
    setNotificationsEnabled(isNotificationEnabled());
  }, []);

  const handleEnableNotifications = async () => {
    const granted = await requestNotificationPermission();
    setNotificationsEnabled(granted);
    if (granted) {
      toast({ title: "Notifications enabled", description: "You'll receive alerts when opportunities are found" });
    } else {
      toast({ title: "Notifications blocked", description: "Please enable notifications in your browser settings", variant: "destructive" });
    }
  };

  const testAlertSound = () => {
    playAlertSound(soundVolume / 100, 4); // Test with normal ROI level
    toast({ title: "Test alert", description: "This is how a 3-5% ROI alert sounds" });
  };

  // Toggle preset market selection
  const togglePreset = (presetId: string) => {
    setSelectedPresets(prev => 
      prev.includes(presetId) 
        ? prev.filter(id => id !== presetId)
        : [...prev, presetId]
    );
  };

  const { data: watchlistItems = [], isLoading: watchlistLoading } = useQuery<Watchlist[]>({
    queryKey: ["/api/watchlist"],
  });

  const { data: alertsList = [], isLoading: alertsLoading } = useQuery<Alert[]>({
    queryKey: ["/api/alerts"],
  });

  const unreadAlerts = useMemo(() => alertsList.filter(a => !a.isRead), [alertsList]);

  const addToWatchlistMutation = useMutation({
    mutationFn: async (data: any) => {
      return apiRequest("POST", "/api/watchlist", data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/watchlist"] });
      toast({ title: "Added to watchlist", description: `${marketName} is now being monitored` });
      setMarketName("");
      setSiteAYes("");
      setSiteBYes("");
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to add to watchlist", variant: "destructive" });
    },
  });

  const deleteWatchlistMutation = useMutation({
    mutationFn: async (id: string) => {
      return apiRequest("DELETE", `/api/watchlist/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/watchlist"] });
      toast({ title: "Removed", description: "Market removed from watchlist" });
    },
  });

  const updateWatchlistMutation = useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: any }) => {
      return apiRequest("PATCH", `/api/watchlist/${id}`, updates);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/watchlist"] });
    },
  });

  const markAlertReadMutation = useMutation({
    mutationFn: async (id: string) => {
      return apiRequest("PATCH", `/api/alerts/${id}/read`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/alerts"] });
    },
  });

  const clearAlertsMutation = useMutation({
    mutationFn: async () => {
      return apiRequest("DELETE", "/api/alerts");
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/alerts"] });
      toast({ title: "Alerts cleared" });
    },
  });

  const createAlertMutation = useMutation({
    mutationFn: async (data: any) => {
      return apiRequest("POST", "/api/alerts", data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/alerts"] });
    },
  });

  const handleAddToWatchlist = () => {
    let priceA = parseFloat(siteAYes);
    let priceB = parseFloat(siteBYes);

    if (isNaN(priceA) || isNaN(priceB) || !marketName.trim()) {
      toast({ title: "Invalid input", description: "Please fill in all fields", variant: "destructive" });
      return;
    }

    if (priceA >= 1) priceA = priceA / 100;
    if (priceB >= 1) priceB = priceB / 100;

    const makerResult = calculateBestRoi(siteAName, priceA, siteBName, priceB, parseFloat(investment) || 500, "Maker");
    const takerResult = calculateBestRoi(siteAName, priceA, siteBName, priceB, parseFloat(investment) || 500, "Taker");

    addToWatchlistMutation.mutate({
      marketName: marketName.trim(),
      siteAName,
      siteBName,
      siteAYesPrice: priceA,
      siteBYesPrice: priceB,
      investment: parseFloat(investment) || 500,
      alertThreshold: parseFloat(alertThreshold) || 3.0,
      isActive: true,
    });
  };

  const handleScanMarket = (item: Watchlist) => {
    const makerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Maker");
    const takerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Taker");

    updateWatchlistMutation.mutate({
      id: item.id,
      updates: {
        lastChecked: new Date().toISOString(),
        lastMakerRoi: makerResult.roi,
        lastTakerRoi: takerResult.roi,
      },
    });

    if (makerResult.roi >= item.alertThreshold) {
      const scenarioDesc = makerResult.scenario === 1 
        ? `Buy YES on ${item.siteAName} + Buy NO on ${item.siteBName}`
        : `Buy NO on ${item.siteAName} + Buy YES on ${item.siteBName}`;
      createAlertMutation.mutate({
        watchlistId: item.id,
        marketName: item.marketName,
        makerRoi: makerResult.roi,
        takerRoi: takerResult.roi,
        siteAYesPrice: item.siteAYesPrice,
        siteBYesPrice: item.siteBYesPrice,
        isRead: false,
      });

      // Trigger urgent alert with sound, vibration, flash, and notification
      triggerUrgentAlert(
        "Arbitrage Opportunity Found!",
        `${item.marketName}: ${makerResult.roi.toFixed(2)}% ROI`,
        {
          playSound: soundEnabled,
          vibrate: true,
          flash: true,
          notification: notificationsEnabled,
          soundVolume: soundVolume / 100, // Convert 0-100 to 0-1
          roi: makerResult.roi, // Pass ROI for sound pattern selection
        }
      );

      toast({
        title: "Arbitrage Opportunity Found!",
        description: `${item.marketName}: ${makerResult.roi.toFixed(2)}% ROI (Scenario ${makerResult.scenario})`,
      });
    }
  };

  const scanAllMarkets = () => {
    watchlistItems.forEach((item) => {
      if (item.isActive) {
        handleScanMarket(item);
      }
    });
    setLastScan(new Date());
    toast({ title: "Scan complete", description: `Checked ${watchlistItems.filter(i => i.isActive).length} markets` });
  };

  // Watchlist auto-scan effect - periodically scans watchlist items when enabled
  useEffect(() => {
    if (!autoScanEnabled || watchlistItems.length === 0) return;
    
    const intervalMinutes = parseInt(scanInterval);
    // Validate interval - must be a positive number, minimum 1 minute
    if (isNaN(intervalMinutes) || intervalMinutes < 1) return;
    
    const intervalMs = intervalMinutes * 60 * 1000;
    const interval = setInterval(() => {
      let foundOpportunities = false;
      
      watchlistItems.forEach((item) => {
        if (item.isActive) {
          const makerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Maker");
          
          // Check if this meets the alert threshold
          if (makerResult.roi >= item.alertThreshold) {
            foundOpportunities = true;
            handleScanMarket(item);
          } else {
            // Just update ROI without creating alerts
            const takerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Taker");
            updateWatchlistMutation.mutate({
              id: item.id,
              updates: {
                lastChecked: new Date().toISOString(),
                lastMakerRoi: makerResult.roi,
                lastTakerRoi: takerResult.roi,
              },
            });
          }
        }
      });
      
      // Play sound if opportunities were found and sound is enabled
      if (foundOpportunities && soundEnabled) {
        // Find the highest ROI to determine alert level
        const highestRoi = Math.max(...watchlistItems
          .filter(i => i.isActive && i.lastMakerRoi && i.lastMakerRoi >= i.alertThreshold)
          .map(i => i.lastMakerRoi || 0)
        );
        playAlertSound(soundVolume / 100, highestRoi);
      }
      
      setLastScan(new Date());
    }, intervalMs);
    
    return () => clearInterval(interval);
  }, [autoScanEnabled, scanInterval, watchlistItems, soundEnabled]);

  // Add selected preset markets to watchlist
  const addSelectedPresets = () => {
    const presetsToAdd = PRESET_MARKETS.filter(p => selectedPresets.includes(p.id));
    if (presetsToAdd.length === 0) {
      toast({ title: "No markets selected", description: "Check the markets you want to add", variant: "destructive" });
      return;
    }
    
    presetsToAdd.forEach(preset => {
      addToWatchlistMutation.mutate({
        marketName: preset.name,
        siteAName: preset.siteA,
        siteBName: preset.siteB,
        siteAYesPrice: 0.5, // Default placeholder
        siteBYesPrice: 0.5, // Default placeholder
        investment: parseFloat(investment) || 500,
        alertThreshold: parseFloat(alertThreshold) || 3,
        isActive: true,
      });
    });
    
    setSelectedPresets([]);
    toast({ title: "Markets added", description: `Added ${presetsToAdd.length} markets to watchlist` });
  };

  return (
    <div className="container mx-auto px-4 py-6 max-w-4xl">
      <div className="flex items-center justify-between gap-4 mb-6 flex-wrap">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Eye className="w-6 h-6 text-blue-500" />
            Sentinel
          </h1>
          <p className="text-sm text-muted-foreground">Market watchlist and alerts</p>
        </div>
        {unreadAlerts.length > 0 && (
          <Badge variant="destructive" className="animate-pulse" data-testid="badge-unread-alerts">
            {unreadAlerts.length} alerts
          </Badge>
        )}
      </div>

      <Card className="mb-6">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Plus className="w-5 h-5" />
              Add Market to Watchlist
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="md:col-span-2">
                <Label htmlFor="marketName">Market Name</Label>
                <Input
                  id="marketName"
                  value={marketName}
                  onChange={(e) => setMarketName(e.target.value)}
                  placeholder="e.g. SEC Solana ETF Approval"
                  data-testid="input-market-name"
                />
              </div>
              <div>
                <Label htmlFor="siteAName">Platform A</Label>
                <Select value={siteAName} onValueChange={setSiteAName}>
                  <SelectTrigger data-testid="select-site-a">
                    <SelectValue placeholder="Select platform" />
                  </SelectTrigger>
                  <SelectContent>
                    {PLATFORMS.map((p) => (
                      <SelectItem key={p.id} value={p.name}>
                        {p.name} ({p.feeType})
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div>
                <Label htmlFor="siteBName">Platform B</Label>
                <Select value={siteBName} onValueChange={setSiteBName}>
                  <SelectTrigger data-testid="select-site-b">
                    <SelectValue placeholder="Select platform" />
                  </SelectTrigger>
                  <SelectContent>
                    {PLATFORMS.map((p) => (
                      <SelectItem key={p.id} value={p.name}>
                        {p.name} ({p.feeType})
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              <div>
                <Label htmlFor="siteAYes">{siteAName} YES Price</Label>
                <Input
                  id="siteAYes"
                  type="number"
                  value={siteAYes}
                  onChange={(e) => setSiteAYes(e.target.value)}
                  placeholder="e.g. 28 or 0.28"
                  data-testid="input-site-a-yes"
                />
              </div>
              <div>
                <Label htmlFor="siteBYes">{siteBName} YES Price</Label>
                <Input
                  id="siteBYes"
                  type="number"
                  value={siteBYes}
                  onChange={(e) => setSiteBYes(e.target.value)}
                  placeholder="e.g. 39 or 0.39"
                  data-testid="input-site-b-yes"
                />
              </div>
              <div>
                <Label htmlFor="investment">Investment ($)</Label>
                <Input
                  id="investment"
                  type="number"
                  value={investment}
                  onChange={(e) => setInvestment(e.target.value)}
                  placeholder="500"
                  data-testid="input-investment"
                />
              </div>
              <div>
                <Label htmlFor="alertThreshold">Alert Threshold (%)</Label>
                <Input
                  id="alertThreshold"
                  type="number"
                  value={alertThreshold}
                  onChange={(e) => setAlertThreshold(e.target.value)}
                  placeholder="3.0"
                  data-testid="input-alert-threshold"
                />
              </div>
            </div>
            <Button 
              onClick={handleAddToWatchlist} 
              disabled={addToWatchlistMutation.isPending}
              className="w-full"
              data-testid="button-add-watchlist"
            >
              <Plus className="w-4 h-4 mr-2" />
              Add to Watchlist
            </Button>
          </CardContent>
        </Card>

        <Card className="mb-6">
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center gap-2 text-lg">
              Supported Platforms
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              {PLATFORMS.map((platform) => (
                <div key={platform.id} className="p-3 rounded-md border bg-muted/30" data-testid={`platform-info-${platform.id}`}>
                  <div className="font-medium text-sm">{platform.name}</div>
                  <div className="text-xs text-muted-foreground">{platform.feeType} fees</div>
                  <div className="text-xs text-muted-foreground mt-1">{platform.description}</div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        <Card className="mb-6">
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center gap-2 text-lg">
              <Check className="w-5 h-5" />
              Quick Add Markets
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-muted-foreground">Select markets to add to your watchlist:</p>
            <div className="space-y-3">
              {PRESET_MARKETS.map((preset) => {
                const alreadyAdded = watchlistItems.some(w => w.marketName === preset.name);
                return (
                  <div 
                    key={preset.id} 
                    className={`flex items-center gap-3 p-3 rounded-md border ${alreadyAdded ? 'bg-muted/50 opacity-60' : 'hover-elevate'}`}
                    data-testid={`preset-${preset.id}`}
                  >
                    <Checkbox
                      id={preset.id}
                      checked={selectedPresets.includes(preset.id)}
                      onCheckedChange={() => togglePreset(preset.id)}
                      disabled={alreadyAdded}
                      data-testid={`checkbox-${preset.id}`}
                    />
                    <label 
                      htmlFor={preset.id} 
                      className={`flex-1 cursor-pointer ${alreadyAdded ? 'line-through' : ''}`}
                    >
                      <div className="font-medium">{preset.name}</div>
                      <div className="text-sm text-muted-foreground">{preset.siteA} vs {preset.siteB}</div>
                    </label>
                    {alreadyAdded && <Badge variant="secondary">Added</Badge>}
                  </div>
                );
              })}
            </div>
            <Button 
              onClick={addSelectedPresets}
              disabled={selectedPresets.length === 0 || addToWatchlistMutation.isPending}
              className="w-full"
              data-testid="button-add-selected-presets"
            >
              <Plus className="w-4 h-4 mr-2" />
              Add Selected Markets ({selectedPresets.length})
            </Button>
          </CardContent>
        </Card>

        <Card className="mb-6">
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center gap-2 text-lg">
              <RefreshCw className="w-5 h-5" />
              Scan Settings
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between gap-4">
              <div className="flex-1">
                <div className="font-medium">Auto-Scan Markets</div>
                <p className="text-sm text-muted-foreground">
                  {autoScanEnabled 
                    ? `Scanning every ${scanInterval} minute${scanInterval !== "1" ? "s" : ""}`
                    : "Enable to automatically find arbitrage opportunities"
                  }
                </p>
                {lastScan && (
                  <p className="text-xs text-muted-foreground mt-1">
                    Last scan: {lastScan.toLocaleTimeString()}
                  </p>
                )}
              </div>
              <Switch 
                checked={autoScanEnabled} 
                onCheckedChange={setAutoScanEnabled}
                data-testid="switch-auto-scan"
              />
            </div>
            {autoScanEnabled && (
              <div className="flex items-center gap-4">
                <Label htmlFor="scan-interval" className="whitespace-nowrap">Scan every:</Label>
                <Select value={scanInterval} onValueChange={setScanInterval}>
                  <SelectTrigger className="w-32" data-testid="select-scan-interval">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="5">5 minutes</SelectItem>
                    <SelectItem value="10">10 minutes</SelectItem>
                    <SelectItem value="15">15 minutes</SelectItem>
                    <SelectItem value="30">30 minutes</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}
            <div className="border-t pt-4">
              <div className="font-medium mb-2">Platforms to Scan</div>
              <p className="text-xs text-muted-foreground mb-3">
                Toggle which platforms to include in arbitrage scanning
              </p>
              <div className="flex gap-3 flex-wrap">
                {PLATFORMS.map((platform) => (
                  <Button
                    key={platform.id}
                    variant={enabledPlatforms.includes(platform.name) ? "default" : "outline"}
                    size="sm"
                    onClick={() => togglePlatform(platform.name)}
                    data-testid={`toggle-platform-${platform.id}`}
                  >
                    {enabledPlatforms.includes(platform.name) ? (
                      <Check className="w-4 h-4 mr-1" />
                    ) : null}
                    {platform.name}
                  </Button>
                ))}
              </div>
              {enabledPlatforms.length === 2 && (
                <p className="text-xs text-muted-foreground mt-2">
                  Only showing {enabledPlatforms.join(" vs ")} matches
                </p>
              )}
            </div>
          </CardContent>
        </Card>

        <div className="mb-6">
          <MarketBrowser 
            autoRefresh={autoScanEnabled}
            refreshInterval={scanInterval}
            enabledPlatforms={enabledPlatforms}
            onScanComplete={() => setLastScan(new Date())}
          />
        </div>

        <Card className="mb-6">
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center gap-2 text-lg">
              <Bell className="w-5 h-5" />
              Alert Settings
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between gap-4">
              <div className="flex-1">
                <div className="font-medium flex items-center gap-2">
                  {notificationsEnabled ? <BellRing className="w-4 h-4 text-green-500" /> : <BellOff className="w-4 h-4 text-muted-foreground" />}
                  Push Notifications
                </div>
                <p className="text-sm text-muted-foreground">Get notified when opportunities are found</p>
              </div>
              {notificationsEnabled ? (
                <Badge variant="secondary">Enabled</Badge>
              ) : (
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={handleEnableNotifications}
                  data-testid="button-enable-notifications"
                >
                  Enable
                </Button>
              )}
            </div>
            <div className="flex items-center justify-between gap-4">
              <div className="flex-1">
                <div className="font-medium flex items-center gap-2">
                  {soundEnabled ? <Volume2 className="w-4 h-4 text-green-500" /> : <VolumeX className="w-4 h-4 text-muted-foreground" />}
                  Sound Alerts
                </div>
                <p className="text-sm text-muted-foreground">Play urgent sound when opportunities are found</p>
              </div>
              <div className="flex items-center gap-2">
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={testAlertSound}
                  data-testid="button-test-sound"
                >
                  Test
                </Button>
                <Switch 
                  checked={soundEnabled} 
                  onCheckedChange={setSoundEnabled}
                  data-testid="switch-sound-enabled"
                />
              </div>
            </div>
            {soundEnabled && (
              <div className="space-y-2 pl-6 border-l-2 border-blue-500/20">
                <div className="flex items-center justify-between gap-4">
                  <Label htmlFor="volume-slider" className="text-sm font-medium">
                    Volume: {soundVolume}%
                  </Label>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        playAlertSound(soundVolume / 100, 6); // Test urgent (>5%)
                        setTimeout(() => playAlertSound(soundVolume / 100, 4), 1500); // Test normal (3-5%)
                        setTimeout(() => playAlertSound(soundVolume / 100, 2), 3000); // Test gentle (1-3%)
                      }}
                      className="text-xs"
                    >
                      Test All Levels
                    </Button>
                  </div>
                </div>
                <Slider
                  id="volume-slider"
                  min={0}
                  max={100}
                  step={5}
                  value={[soundVolume]}
                  onValueChange={(value) => setSoundVolume(value[0])}
                  className="w-full"
                  data-testid="slider-volume"
                />
                <p className="text-xs text-muted-foreground">
                  Different alert patterns: <span className="text-orange-500 font-medium">Urgent (â‰¥5% ROI)</span>, <span className="text-blue-500 font-medium">Normal (3-5%)</span>, <span className="text-green-500 font-medium">Gentle (1-3%)</span>
                </p>
              </div>
            )}
            <p className="text-xs text-muted-foreground border-t pt-3">
              Note: Web apps cannot fully override Do Not Disturb mode. For critical alerts, enable notifications and sounds, and add this app to your phone's DND exceptions.
            </p>
          </CardContent>
        </Card>

        <div className="flex items-center justify-between gap-4 mb-4 flex-wrap">
          <h2 className="text-xl font-semibold flex items-center gap-2">
            <Eye className="w-5 h-5" />
            Watchlist ({watchlistItems.length})
          </h2>
          <Button 
            onClick={scanAllMarkets} 
            disabled={watchlistItems.length === 0}
            data-testid="button-scan-all"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Scan All Markets
          </Button>
        </div>

        {watchlistLoading ? (
          <Card className="p-8 text-center text-muted-foreground">Loading watchlist...</Card>
        ) : watchlistItems.length === 0 ? (
          <Card className="p-8 text-center text-muted-foreground">
            <Eye className="w-12 h-12 mx-auto mb-4 opacity-50" />
            <p>No markets in watchlist</p>
            <p className="text-sm mt-2">Add markets above to start monitoring</p>
          </Card>
        ) : (
          <div className="space-y-3">
            {watchlistItems.map((item) => {
              const makerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Maker");
              const takerResult = calculateBestRoi(item.siteAName, item.siteAYesPrice, item.siteBName, item.siteBYesPrice, item.investment, "Taker");
              const makerRoi = item.lastMakerRoi ?? makerResult.roi;
              const takerRoi = item.lastTakerRoi ?? takerResult.roi;
              const isHot = makerRoi >= item.alertThreshold;

              return (
                <Card 
                  key={item.id} 
                  className={`${isHot ? "border-orange-500/50 bg-orange-500/5" : ""}`}
                  data-testid={`card-watchlist-${item.id}`}
                >
                  <CardContent className="p-4">
                    <div className="flex items-start justify-between gap-4 flex-wrap">
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1 flex-wrap">
                          <h3 className="font-semibold truncate">{item.marketName}</h3>
                          {isHot && (
                            <Badge variant="destructive" className="flex items-center gap-1">
                              <Flame className="w-3 h-3" />
                              HOT
                            </Badge>
                          )}
                          {item.isActive ? (
                            <Badge variant="secondary" className="text-xs">Active</Badge>
                          ) : (
                            <Badge variant="outline" className="text-xs">Paused</Badge>
                          )}
                        </div>
                        <div className="text-sm text-muted-foreground space-y-1">
                          <p>
                            {item.siteAName} YES: <span className="font-mono">${item.siteAYesPrice.toFixed(2)}</span>
                            {" | "}
                            {item.siteBName} NO: <span className="font-mono">${item.siteBYesPrice.toFixed(2)}</span>
                          </p>
                          <p>
                            Investment: <span className="font-mono">${item.investment}</span>
                            {" | "}
                            Alert at: <span className="font-mono">{item.alertThreshold}%</span>
                          </p>
                        </div>
                      </div>
                      <div className="flex flex-col items-end gap-2">
                        <div className="text-right">
                          <div 
                            className={`font-mono font-bold text-lg ${makerRoi > 0 ? "text-green-600 dark:text-green-400" : "text-red-600 dark:text-red-400"}`}
                            data-testid={`text-roi-${item.id}`}
                          >
                            {makerRoi > 0 ? <TrendingUp className="w-4 h-4 inline mr-1" /> : <TrendingDown className="w-4 h-4 inline mr-1" />}
                            {makerRoi.toFixed(2)}%
                          </div>
                          <div className="text-xs text-muted-foreground">Maker ROI</div>
                        </div>
                        <div className="flex items-center gap-1">
                          <Button
                            size="icon"
                            variant="ghost"
                            onClick={() => handleScanMarket(item)}
                            data-testid={`button-scan-${item.id}`}
                          >
                            <RefreshCw className="w-4 h-4" />
                          </Button>
                          <Button
                            size="icon"
                            variant="ghost"
                            onClick={() => updateWatchlistMutation.mutate({ id: item.id, updates: { isActive: !item.isActive } })}
                            data-testid={`button-toggle-${item.id}`}
                          >
                            {item.isActive ? <Eye className="w-4 h-4" /> : <EyeOff className="w-4 h-4" />}
                          </Button>
                          <Button
                            size="icon"
                            variant="ghost"
                            onClick={() => deleteWatchlistMutation.mutate(item.id)}
                            data-testid={`button-delete-${item.id}`}
                          >
                            <Trash2 className="w-4 h-4 text-red-500" />
                          </Button>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              );
            })}
          </div>
        )}

        {alertsList.length > 0 && (
          <div className="mt-8">
            <div className="flex items-center justify-between gap-4 mb-4 flex-wrap">
              <h2 className="text-xl font-semibold flex items-center gap-2">
                <BellRing className="w-5 h-5 text-orange-500" />
                Alerts ({alertsList.length})
              </h2>
              <Button 
                variant="outline" 
                size="sm" 
                onClick={() => clearAlertsMutation.mutate()}
                data-testid="button-clear-alerts"
              >
                Clear All
              </Button>
            </div>
            <div className="space-y-2">
              {alertsList.slice(0, 10).map((alert) => (
                <Card 
                  key={alert.id} 
                  className={`${!alert.isRead ? "border-orange-500/30 bg-orange-500/5" : "opacity-60"}`}
                  data-testid={`card-alert-${alert.id}`}
                >
                  <CardContent className="p-3 flex items-center justify-between gap-4 flex-wrap">
                    <div>
                      <p className="font-medium flex items-center gap-2">
                        {!alert.isRead && <Bell className="w-4 h-4 text-orange-500" />}
                        {alert.marketName}
                      </p>
                      <p className="text-sm text-muted-foreground">
                        Maker: <span className="font-mono text-green-600">{alert.makerRoi.toFixed(2)}%</span>
                        {" | "}
                        Taker: <span className="font-mono">{alert.takerRoi.toFixed(2)}%</span>
                      </p>
                    </div>
                    {!alert.isRead && (
                      <Button 
                        size="sm" 
                        variant="ghost"
                        onClick={() => markAlertReadMutation.mutate(alert.id)}
                        data-testid={`button-mark-read-${alert.id}`}
                      >
                        Mark Read
                      </Button>
                    )}
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}
    </div>
  );
}
